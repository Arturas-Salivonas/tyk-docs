---
title: "7. Step-by-step tutorial"
date: 2020-09-14
menu:
  main:
    parent: "UDG Getting Started"
weight: 7
---

{{< youtube TGITEGnJH6c >}} 

In this getting started tutorial we will combine 2 different HTTP services (Users and Reviews) into one single unified UDG API. Instead of querying these two services separately (and probably merging their responses later) we'll use UDG to get result from both the API's in one single response.

### Prerequisites 

- Access to Tyk Dashboard
- Node.JS v.13^ (only to follow this example)

### Running example services locally

{{< youtube 9UEgR0VTVmE >}} 

Clone repo

```bash
git clone https://github.com/jay-deshmukh/example-rest-api-for-udg.git
```

Run it locally
```bash
cd example-rest-api-for-udg
```

```bash
npm i
```

```bash
npm run build
```

```bash
npm start
```

You should see following in your terminal

```
Users Service Running on http://localhost:4000
Review service running on http://localhost:4001
```

<hr/>

Now that we have Users service running on port `4000` and Reviews service running on port `4001` let's see how we can combine these two into one single UDG API in following tutorial.

{{< youtube ocdY0IKwX_I >}} 

1. Create API

To start with a Universal Data Graph from scratch head over to the dashboard and click on “APIs” in the left menu. Then click the `“Add New API”` and `UDG`. You might want to give your Universal Data Graph an individual name (i.e. `User-Reviews-Demo`)


2. Set Authentication

To get started easily we'll set the API to `Keyless(Open)`. To do this, scroll down to the Authentication section.

{{< note success >}}
**Note**

The API authentication is set to Keyless for demo purposes, it’s not recommended to use this setting in production, we’ll explore how to secure the UDG later in this guide.
{{< /note >}}

3. Configure Schema

Switch to schema tab in your designer and you should already see a default schema. We will edit the schema as follows to connect with our datasources later.

```gql
type Mutation {
  default: String
}

type Query {
  user(id: String): User
}

type Review {
  id: String
  text: String
  userId: String
  user: User
}

type User {
  id: String
  username: String
  reviews: [Review]
}

```

You can also import an existing schema using the import feature, file types supported :  `gql` , `graphql` and `graphqls`.

4. Save

Click on save button and that should create our first UDG API

<hr/>

Now if we try to query our UDG API it should error at this moment as we do not have any data-source attached to it, let's see how we can do that in next section.

{{< youtube tjzjaykQqkg >}} 

Upon navigating to schema tab on API details page you’ll see a split screen view with schema and user interface for available fields to configure the datasource.

You can attach datasource to each individual field and can also re-use the datasource for multiple fields for performance benefits in case it has similar configuration (it needs to use the same upstream URL and method).

We will start with attaching datasource to user query using following approach. 

#### 1. Select field to attach datasource.
Upon selecting the `Users` field on type `Query`, you'll see the options to configure that field for following kinds of datasources.

* REST
* GraphQL
* Kafka

#### 2. Select datasource type.

Since our upstream services are REST, we'll select REST as datasource type but other kind of datasources can be used as well:

* *Use external data source*: Will allow to configure the field to resolve with the external API (outside Tyk environment)
* *Using exiting APIs*: Which will allow to configure the field with the API that already exists in Tyk environment.
* *Re-use already configured data source*: If you already have configured a data source for the same API you can re-use the same data-source. If the data source is reused the endpoint will only be called once by Tyk.

You can learn more about it [here](../../concepts/datasources/)

#### 3. Configure datasource details.

Configure the data source with the following fields

**Name**

 Enter a unique datasource name your configuration to reuse it in the future. We will name this as `getUserById` for the given example.

**URL**

We will use the URL for our `Users` service which returns details of an user for given `id` i.e `http://localhost:4000/users/:id`.

To dynamically inject the `id` for every request made, we can use templating syntax and inject `id` with user supplied argument or we can also use session object.

To avoid typos in template you can use the UI component to automatically create a template for you. You can select from the available argument and object template options from the list generated by input component which is triggered by entering `{` in input.

To learn more about arguments click [here](../../concepts/arguments/)

To learn more about reusing response fields click [here](../../concepts/reusing_response_fields)

#### 4. Enter datasource name.

Enter a unique datasource name your configuration to reuse it in the future. We will name this as `getUserById` for the given example

#### 5. Select HTTP method for the URL.

You can select the HTTP method for your upstream url. Which should be `GET` in our case.

#### 6. Add headers (Optional)

If you upstream expects headers, you can supply them using this.
You can also use templating syntax here to reuse request headers.

#### 7. Select field mapping

Keep the field mapping disabled by default.
You can use field mapping to map the API response with your schema.

You can learn more about field mapping [here](../../concepts/field_mappings)

#### 8. Save data source

It is important to save datasource configuration before updating the API in order to reflect the changes in your API definition.

#### 9. Update API and Test

Click Update the API.

You can now query your UDG API of `user` using the Playground tab in API designer

```gql
query getUser {
  user(id:"1"){
    username
    id
    reviews {
      id
      text
      user {
        id
      }
      
    }
  }
}
```

The above query should return the response as follows 

```json
{
  "data": {
    "user": {
      "username": "John Doe",
      "id": "1",
      "reviews": null
    }
  }
}
```

#### Challenge

1. Try to resolve `reviews` field on type `Users`
2. Try to resolve `users` field on type `Reviews`

As you can see our query resolved for user details but returns `null` for `reviews`. 

This happens because we haven't defined datasource on field level for `reviews` on type `User`. 

```
Notes
- For reviews field on type User
- - Description :: get reviews by userId
- - URL :: http://localhost:4001/reviews/:userId
- - Method :: GET

- For users field on type Review
- - Description :: get user details by Id
- - URL :: http://localhost:4000/users/:userId
- - Method :: GET

- You can reuse response filed using templating syntax example `{{.object.id}}`
```

{{< note success >}}
**Note**

You can find the solution for the challenge in the above video.

{{< /note >}}

<hr />

Now that we have linked datasources for our queries, let's see how we can do the same for mutations in the next section.

{{< youtube za2KdDQSCnI >}} 

Now that we have attached datasources to our `Query` in the schema let's try to do the same for `Mutation`.

### 1. Update Schema 

```gql
type Mutation {
  addReview(text: String, userId: String): Review
  deletReview(reviewId: String): String
}
```

We’ll update the Mutatation type as above where we’ll add two operations 

* `addReview`: Which accepts two `arguments` (i.e `text` and `userId`) and adds a new review by making a `POST` request to `http://localhost:4001/reviews` endpoint, which expects something like the following in the request payload 

```
{
    "id": "1", // UserId of the user posting review 
    "text": "New Review by John Doe11" // review text
}
```
* `deleteReview`: Which accepts one `argument` (i.e `reviewId`), that deletes a review by making a `DELETE` request to `http://localhost:4001/reviews/:reviewId`

### 2. Configure datasource. 

Follow these steps to configure a data source for the `Mutation`.

  * Navigate to schema tab in the api where you would see the split screen view of schema editor on left and list of configurable fields on right
  * Select `addReview` field from `Mutation` type
  * Select `REST` option
  * Set a unique datasource name
  * Set the URL as `http://localhost:4001/reviews`
  * Select method type as `POST`
  * Set request body to relay the graphql arguments to our upstream payload as follows:

  ```
  {
    "text": "{{.arguments.text}}",
    "userId": "{{.arguments.userId}}"
    }
  ```
  * Update the API

### 3. Execute mutation operation

We can now test our mutation operation with the playground in API designer using the following operation

```gql
mutation AddReview {
  addReview(text: "review using udg", userId:"1"){
    id
    text
  }
}
```

That should return us the following response:

```gql
{
  "data": {
    "addReview": {
      "id": "e201e6f3-b582-4772-b95a-d25199b4ab82",
      "text": "review using udg"
    }
  }
}

```


### Challenge

Configure a datasource to delete a review using review id.

```
Notes

- For users field on type Review
- - Description :: delete review using reviewId
- - URL :: http://localhost:4001/reviews/:reviewId
- - Method :: DELETE

- Enable field mapping to map your API response 

```
{{< note success >}}
**Note**

You can find the solution for the challenge in the above video.

{{< /note >}}

<hr />

Now that we have a good idea how we could do CRUD operations with UDG APIs, let's see how we can secure them using policies.

{{< youtube lRLLFLv2rN4 >}} 

Due to the nature of graphql, clients can craft complex or large queries which can cause your upstream APIs to go down or have performance issues.

Some of the common strategies to mitigate these risks include 

- Rate limiting
- Throttling
- Query depth limiting


For this tutorial we'll mitigate these risks using `Query Depth Limit` but you can also use common strategies like rate limiting and throttling, which you can read more about [here](../../../getting-started/key-concepts/rate-limiting/)


### 1. Set authentication mode

In you Api designer core settings tab scroll down to Authentication section and set the authentication mode `Authentication Token` and update the API.

Our API is not open and keyless anymore and would need appropriate Authentication token to execute queries.


### 2. Applying to query depth

Currently if users want they could run queries with unlimited depth as follows 

```gql
query getUser {
  user(id: "1") {
    reviews {
      user {
        reviews {
          user {
            reviews {
              user {
                reviews {
                  user {
                    id
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

```

To avoid these kind of scenarios we will set query depth limit on the keys created to access this API.

Although we can directly create keys by selecting this API but we'll use policy as it will make it easier to update keys for this API in future. You can read more about policies [here](../../../getting-started/key-concepts/what-is-a-security-policy/)

##### Create Policy
- Navigate to policies page
- Click Add Policy
- Select our API from Access Rights table
- Expand `Global Limits and Quota` section
- Unselect `Unlimited Query Depth` and set limit to `5`
- Switch to configuration tab
- Set policy name (eg. user-reviews-policy)
- Set expiration date for the keys that would be created using this policy
- Click on create policy

##### Create a key using above policy
- Navigate to keys page
- Click Add Key
- Select our newly created policy
- Click create key
- Copy the key ID

Now if you try to query our UDG API using the  key you should see an error as follows

```json
{
  "error": "depth limit exceeded"
}
```

{{< note success >}}
**Note**

Watch the video above to see how you can use these policies to publish your UDG APIs on your portal with documentation and playground.

{{< /note >}}


{{< youtube EBza1BFegrk >}} 

It is also possible to restrict user's based on fields using policies. For example you can create two policies 

1. For read-only access for users to only execute queries.

2. For read and write access to run mutations and queries both. 

### Creating keys with read-only access

##### Create Policy
    - Navigate to policies page
    - Click Add Policy
    - Select our API from Access Rights table
    - Expand Api panel under global section
    - Toggle Field-Based Permissions and check Mutation
    - Switch to configuration tab
    - Set policy name (eg. user-reviews-policy-read-only)
    - Set expiration date for the keys that would be created using this policy
    - Click on create policy

Now keys created using these policies cannot be used for mutations.

**Min Version: Tyk v3.2.0**

You’re able to configure upstream Headers dynamically, that is, you’re able to inject Headers from the client request into UDG upstream requests. For example, it can be used to access protected upstreams.

The syntax for this is straight forward:

```
{{.request.headers.someheader}}
```

  In your data sources, define your new Header name and then declare which request header's value to use:

  {{< img src="/img/dashboard/udg/getting-started/request-forward-syntax.png" alt="Forwarding Headers" >}}

  That's it!

{{< note success >}}
**Note**

A JSON string has to be escaped before using as a header value. For example:
```
{\"hello\":\"world\"}
```

{{< /note >}}